#include <iostream>
#include <cmath>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <vector>
#include <numeric>
#include <algorithm>
#include <iomanip>   // For setting precision
#include <sys/time.h>
#include <random>

#define ui64 u_int64_t

// Function to get current time in microseconds
double dml_micros() {
    static struct timezone tz;
    static struct timeval tv;
    gettimeofday(&tv, &tz);
    return ((tv.tv_sec * 1000000.0) + tv.tv_usec);
}

// Function to generate Gaussian noise using Box-Muller transform
double gaussian_box_muller(gsl_rng* rng) {
    return gsl_ran_gaussian(rng, 1.0); // 1.0 is the standard deviation (mean=0)
}

double black_scholes_monte_carlo(double f1, double f2, double f3, ui64 K, ui64 num_simulations, gsl_rng* rng) {
    double sum_payoffs = 0.0;

    ui64 i = 0;
    ui64 unroll_factor = 8;
    alignas(64) double sum_payoff_local[8] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
    
    for (; i + unroll_factor <= num_simulations; i += unroll_factor) {
        double Z1 = gaussian_box_muller(rng);
        double Z2 = gaussian_box_muller(rng);
        double Z3 = gaussian_box_muller(rng);
        double Z4 = gaussian_box_muller(rng);
        double Z5 = gaussian_box_muller(rng);
        double Z6 = gaussian_box_muller(rng);
        double Z7 = gaussian_box_muller(rng);
        double Z8 = gaussian_box_muller(rng);

        double ST1 = f1 * exp(f2 * Z1);
        double ST2 = f1 * exp(f2 * Z2);
        double ST3 = f1 * exp(f2 * Z3);
        double ST4 = f1 * exp(f2 * Z4);
        double ST5 = f1 * exp(f2 * Z5);
        double ST6 = f1 * exp(f2 * Z6);
        double ST7 = f1 * exp(f2 * Z7);
        double ST8 = f1 * exp(f2 * Z8);

        sum_payoff_local[0] += (ST1 > K) * (ST1 - K);
        sum_payoff_local[1] += (ST2 > K) * (ST2 - K);
        sum_payoff_local[2] += (ST3 > K) * (ST3 - K);
        sum_payoff_local[3] += (ST4 > K) * (ST4 - K);
        sum_payoff_local[4] += (ST5 > K) * (ST5 - K);
        sum_payoff_local[5] += (ST6 > K) * (ST6 - K);
        sum_payoff_local[6] += (ST7 > K) * (ST7 - K);
        sum_payoff_local[7] += (ST8 > K) * (ST8 - K);
    }

    for (; i < num_simulations; ++i) {
        double Z = gaussian_box_muller(rng);
        double ST = f1 * exp(f2 * Z);
        sum_payoffs += (ST > K) * (ST - K);
    }

    sum_payoffs += sum_payoff_local[0] + sum_payoff_local[1] + sum_payoff_local[2] + sum_payoff_local[3] + sum_payoff_local[4] + sum_payoff_local[5] + sum_payoff_local[6] + sum_payoff_local[7];

    return f3 * (sum_payoffs / num_simulations);
}

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <num_simulations> <num_runs>" << std::endl;
        return 1;
    }

    ui64 num_simulations = std::stoull(argv[1]);
    ui64 num_runs = std::stoull(argv[2]);

    // Input parameters
    ui64 S0 = 100;                   // Initial stock price
    ui64 K = 110;                    // Strike price
    double T = 1.0;                   // Time to maturity (1 year)
    double r = 0.06;                  // Risk-free interest rate
    double sigma = 0.2;               // Volatility
    double q = 0.03;                  // Dividend yield

    double factor1 = S0 * exp((r - q - 0.5 * sigma * sigma) * T);
    double factor2 = sigma * sqrt(T);
    double factor3 = exp(-r * T);

    // Initialize GSL random number generator
    std::random_device rd;
    unsigned long seed = rd();  // Generate seed using random_device
    gsl_rng_env_setup();

    const gsl_rng_type* T_rng;
    gsl_rng* rng = gsl_rng_alloc(gsl_rng_mt19937);

    gsl_rng_set(rng, seed); // Use the seed generated by random_device

    std::cout << "Global initial seed: " << seed << " argv[1]= " << argv[1] << "     argv[2]= " << argv[2] << std::endl;

    std::vector<double> bms;
    double t1 = dml_micros();
    for (ui64 run = 0; run < num_runs; ++run) {
        double result = black_scholes_monte_carlo(factor1, factor2, factor3, K, num_simulations, rng);
        bms.push_back(result);
    }
    double t2 = dml_micros();

    // Calculate statistics
    double min_val = *std::min_element(bms.begin(), bms.end());
    double max_val = *std::max_element(bms.begin(), bms.end());
    double mean = std::accumulate(bms.begin(), bms.end(), 0.0) / bms.size();

    double variance = 0.0;
    for (double value : bms) {
        variance += (value - mean) * (value - mean);
    }
    variance /= bms.size();
    double stddev = std::sqrt(variance);

    double dev_percent = (stddev * 100.0) / mean;

    std::cout << std::fixed << std::setprecision(6)
              << "Min: " << min_val << "\n"
              << "Max: " << max_val << "\n"
              << "Mean: " << mean << "\n"
              << "Standard Deviation: " << stddev << "\n"
              << "Standard Deviation (% of Mean): " << dev_percent << "%" << "\n"
              << "Time taken: " << (t2 - t1) / 1000000.0 << " seconds" << std::endl;

    // Free GSL RNG memory
    gsl_rng_free(rng);

    return 0;
}